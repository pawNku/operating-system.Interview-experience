# Operating-system.Interview-experience
操作系统的面经整理未完待续~

### 1.基本概念
>Q:并发和并行

>Ans:
* 并发是宏观意义上的一段时间内能同时完成多任务 操作系统通过引入进程和线程来实现并发
* 并行是真正意义上的同一时刻多任务操作的
>Q:共享

>Ans:
* 共享就是说系统中的资源可以被多个并发的过程使用 如果没有了共享变量 进程之间也就隔离了
* 比如互斥共享就是同一时间只有一个进程可以访问 他的资源叫做临界资源
>Q:分时系统

>Ans:
* 在CPU上只有很少的脑容量 只有为数不多的寄存器能临时记一些东西 但是却跑得飞快基本上人间的1秒==CPU做10亿次动作了
* 所以当多进程多个程序运行在CPU中 一个耗时操作呀5分钟 一个读写瞬间完成 如果按序的话 人类看来就好像假死了 但是CPU在拼命的计算耗时操作
把CPU的运行时间分为一个个时间片 这样每个程序进来都只执行一段时间就必须让出CPU 虽然这样但是1秒==人类10亿秒 所以不停的切换人类也看不出来
* 人们一边听歌 一边上网 一边聊QQ 但是其实COU是音乐播放器先运行十几毫秒 再浏览器运行十几毫秒这样的
>Q:分块装入内存

>Ans:
* 因为分时系统的出现 所以很多程序都想到内存里爽一把 但是内存前面说了脑容量很小很小
* 所以对每个程序 不要全部装入内存 分块装载 把最重要的代码指令先装进来 后面再按需装载
* -->每一块也就叫做页框了 
* 又因为时间局部性和空间局部性 程序会倾向于这一块或者这几块上运行的 经常用的和附近用的
>Q.虚拟内存：分页

>Ans:
* 虚拟地址：就是给每个程序提供一个超级大的空间比如4GB 但是都是虚拟的 程序的指令都是操作这些的虚拟地址的 但是CPU的内存管理单元MMU都把他隐射到真实的物理内存上
* 基于分块 所以虚拟地址也分块叫做页 大小和物理地址的页框一样大 这样也方便隐射 页表用来隐射的表
* 如果要被指令访问的页还没有隐射到页框那么就会导致缺页 这样就得去硬盘上取
* 以后的地址就分为了-->页号和偏移量 虚拟地址==页号+偏移量 然后页号可以对应到物理地址的页框表 然后真实地址==页表+偏移量
* 优化：把经常访问的页表放入缓存里 同样也是局部性原理
>Q.分段+分页

>Ans:
* 分段的出现：是因为程序不爽了 比如程序分为==代码段+数据段+堆栈段 这样有时候程序只要读代码段就可以抛出异常了 省事
* 所以现在老大除了页表还要维持段表
* 地址-->段号+偏移量 然后段号通过段表找到基址然后+偏移量 得到的线性地址 最后通过页表转换就可以得到了真正的物理地址了
>Q.分页与分段的对比

>Ans:
* 透明性：分页是透明的 而分段需要程序员自己划分
* 地址空间的维度：分页是一维的 而分段是二维的
* 大小：分页是不可变的一般==页框 分段是人为动态可变的
* 出现的原因：分页是为了虚拟内存 分段是为了使程序和数据可以划分为逻辑上的独立的地址空间
>Q:线程

>Ans:
* 为了解决比如Wps里的断电啊 一边打字一边保存 但是如果两个进程则保存与IO打交道还涉及硬盘那可能慢的爆炸了-->假死了
* 这样就可以把进程当做一个资源的容器里面放几个轻量级的进程-->线程 然后这些线程共享进程的资源 地址空间全局变量等
* 另外线程也有自己独特的地方 就是要记住自己运行到哪行指令了 也就是寄存器和调用栈了 --> 也是为了像切换进程一样切换线程
>Q:进程和线程的区别

>Ans:
* 最大的区别进程拥有资源 而线程不拥有资源 但是线程可以访问进程的资源
* 线程是独立的调度单位 线程的切换不会导致进程的切换
* 进程的创建和摧毁都是要巨大的开销的IO、内存空间啊 但是线程的切换 哎 只要一手记录 就是寄存器和调用栈
* 通信 进程需要IPC 但是线程因为在同一进程所以可以直接通信

### 2.进程的管理
>Q:进程状态的切换

>Ans:
* 状态有：就绪状态-->等待被调用 运行状态 和阻塞状态-->等待资源
* ps：就绪和运行是双向的 就绪-->运行可以通过COU调度算法 运行-->就绪分配的时间撸完了等待 而阻塞状态是缺少资源资源资源 不包括CPU时间
>Q:进程的调度算法

>Ans:
1. 批量处理算法：最普通了量不大的时候一次性搞完
* 先来先服务：按照请求的顺序只适用于长作业 因为短作业一旦等待了长作业就毫无意义了
* 短作业优先：不足是 如果有很多长作业可能饿死了 因为一有小呆逼进来就优先小呆逼了
2. 交互式算法：有大量的交互操作了 这样也是为了快速响应罢了
* 
